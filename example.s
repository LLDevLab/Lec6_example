.equ SPH, 0x3E								; Верхний байт Stack Pointer регистра (I/O port address)
.equ SPL, 0x3D								; Нижний байт Stack Pointer регистра (I/O post address)

local_variables:
	; Сохраняем значение регистра r20 в стек будем его использовать в функции
	push r20
	; Сохраняем значение регистра X (r26:r27) в стек
	push r26
	push r27
	
	; Загружаем текущий указатель стека в регистр X
	; тем самым создавая т. н. stack frame
	; В дальнейшем адрес из регистра X будет использоваться для доступа к локальным переменным
	; А сам регистр становиться указателем на адрес начала фрейма (frame pointer или FP для краткости)
	in r26, SPL
	in r27, SPH
	
	; Представим, что нам нужны 2 локальные переменные A и B размером 1 байт каждая
	; Резервируем 2 байта, для стековых переменных
	sbiw r26, 2
	; Устанавливаем новый адрес указателя стека
	out r26, SPL
	out r27, SPH
	; После любого изменения адрес начала фрейма надо вернуть в исходное значение
	adiw r26, 2
	
	; Предположим что первая переменная будет называться - A, а вторая - B
	; Запишем относительные адреса этих переменных
	; A: [FP]
	; B: [FP - 1]
	
	ldi r20, 20
	
	; Загружаем число из регистра r20 в переменную B
	sbiw r26, 1
	st X, r20
	adiw r26, 1
	
	; Загружаем число из переменной B в регистр r20
	sbiw r26, 1
	ld r20, X
	adiw r26, 1
	
	; Удаляем зарезервированные переменные из стека
	; Присваивая указателю стека адрес из указателя фрейма 
	out r26, SPL
	out r27, SPH
	
	; Восстанавливаем значения сохраненных регистров
	pop r27
	pop r26
	pop r20
	
	; Выходим из функции	
	ret